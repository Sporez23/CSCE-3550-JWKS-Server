#include <iostream>
#include <map>
#include <vector>
#include <chrono>
#include <ctime>
#include <openssl/rsa.h>
#include <openssl/pem.h>
#include <openssl/bio.h>
#include <openssl/evp.h>
#include <openssl/rand.h>
#include <sstream>
#include <iomanip>
#include <pistache/endpoint.h>

using namespace std;

// Struct to represent a key pair
struct KeyPair {
    RSA* privateKey;
    RSA* publicKey;
    string kid; // Key ID
    chrono::system_clock::time_point expiry; // Expiry time
};

// Utility function to generate an RSA key pair
KeyPair generateRSAKeyPair(const string& kid, const time_t& expiry_time) {
    KeyPair keyPair;
    keyPair.privateKey = RSA_new();
    keyPair.publicKey = RSA_new();
    keyPair.kid = kid;
    keyPair.expiry = chrono::system_clock::from_time_t(expiry_time);

    // Generate RSA key pair
    RSA_generate_key_ex(keyPair.privateKey, 2048, NULL, NULL);
    RSA_generate_key_ex(keyPair.publicKey, 2048, NULL, NULL);

    return keyPair;
}

// Utility function to convert RSA key to PEM format
string RSAKeyToPEM(RSA* key) {
    BIO* bio = BIO_new(BIO_s_mem());
    PEM_write_bio_RSAPublicKey(bio, key);
    char* buffer;
    long length = BIO_get_mem_data(bio, &buffer);
    string pemKey(buffer, length);
    BIO_free_all(bio);
    return pemKey;
}

class JWKS_Server {
private:
    map<string, KeyPair> keyPairs; // Map to store key pairs

public:
    // Method to add a new key pair
    void addKeyPair(const KeyPair& keyPair) {
        keyPairs[keyPair.kid] = keyPair;
    }

    // Method to serve JWKS endpoint
    string serveJWKS() {
        stringstream jwks;
        jwks << "{\"keys\":[";
        bool first = true;
        for (const auto& pair : keyPairs) {
            if (pair.second.expiry > chrono::system_clock::now()) {
                if (!first) jwks << ",";
                jwks << "{\"kid\":\"" << pair.second.kid << "\",\"pubkey\":\"" << RSAKeyToPEM(pair.second.publicKey) << "\"}";
                first = false;
            }
        }
        jwks << "]}";
        return jwks.str();
    }

    // Method to issue JWT
    string issueJWT(const string& kid, bool useExpiredKey = false) {
        if (keyPairs.find(kid) != keyPairs.end()) {
            if (useExpiredKey || keyPairs[kid].expiry > chrono::system_clock::now()) {
                // In a real scenario, you would use a JWT library to sign the token
                // For simplicity, we just return a dummy token here
                return "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2MzE2NjkwMzYsImlhdCI6MTYzMjA2NDAzNn0.e8ucjNp10NMR1GcvthD0pTz6ls4xVK_UmblAe6BNUU8";
            }
        }
        return ""; // Return empty string if key not found or expired
    }
};

// web server class
class WebServer {
private:
    JWKS_Server jwksServer;

public:
    // Method to start the server
    void start() {
        Pistache::Address addr(Pistache::Ipv4::any(), Pistache::Port(8080));

        auto opts = Pistache::Http::Endpoint::options().threads(1);
        auto httpEndpoint = std::make_shared<Pistache::Http::Endpoint>(addr);

        httpEndpoint->init(opts);
        httpEndpoint->setHandler(createRouter());
        httpEndpoint->serve();
    }

private:
    // Method to create request handler
    std::shared_ptr<Pistache::Http::Handler> createRouter() {
        auto router = std::make_shared<Pistache::Http::Router>();

        // Serve JWKS endpoint
        Pistache::Rest::Routes::Get(router, "/.well-known/jwks.json", Pistache::Rest::Routes::bind(&WebServer::serveJWKS, this));
        
        // Serve /auth endpoint
        Pistache::Rest::Routes::Post(router, "/auth", Pistache::Rest::Routes::bind(&WebServer::serveAuth, this));

        return router;
    }

    // JWKS endpoint handler
    void serveJWKS(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
        auto jwks = jwksServer.serveJWKS();
        response.send(Pistache::Http::Code::Ok, jwks);
    }

    // /auth endpoint handler
    void serveAuth(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
        // Check if "expired" query parameter is present
        bool useExpired = request.query().has("expired");
        auto token = jwksServer.issueJWT("kid_1", useExpired);
        if (!token.empty()) {
            response.send(Pistache::Http::Code::Ok, token);
        } else {
            response.send(Pistache::Http::Code::Internal_Server_Error, "Failed to issue JWT.");
        }
    }
};

// Mock testing client
class TestClient {
public:
    // Method to simulate POST request to /auth
    void testAuthEndpoint(WebServer& server) {
        // Simulate POST request to /auth
        string token = server.jwksServer.issueJWT("kid_1");
        if (!token.empty()) {
            cout << "Received JWT from /auth endpoint: " << token << endl;
        } else {
            cout << "Failed to receive JWT from /auth endpoint." << endl;
        }
    }
};

int main() {
    WebServer server;
    TestClient client;

    server.start(); // Start the web server

    // Simulate blackbox testing
    client.testAuthEndpoint(server);

    return 0;
}
